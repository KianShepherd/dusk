extern copyi(arr: int*, n: int) -> int*;
extern copyd(arr: float*, n: int) -> float*;
extern copys(arr: string, n: int) -> string;
extern copysa(arr: string*, n: int) -> string*;

extern ialloc(n: int) -> int*;
extern falloc(n: int) -> float*;
extern newstruct(n: int) -> void*;

extern del(arr: int*) -> int;
extern delet(arr: void*);
fn delete(arr: void*) {
    delet(arr);
}

extern ftoi(a: float) -> int;
extern ftos(a: float) -> string;

extern itof(a: int) -> float;
extern itos(a: int) -> string;

extern ltof(a: long) -> float;
extern ltoi(a: long) -> int;
extern ltos(a: long) -> string;

extern stoi(a: string) -> int;
extern stof(a: string) -> float;

extern input() -> string;
extern readfile(filename: string) -> string;

extern count_substr(str: string, substr: string) -> int;
extern split(str: string, on: string) -> string*;




fn split<int>(mut vec: void*, str: string, on: string){
    let count: int = count_substr(str, on) + 1;
    let split_str: string* = split(str, on);
    for (let mut i: int = 0; i < count; i = i + 1) {
        ipush_back(vec, stoi(split_str[i]));
    }
}

fn split<float>(mut vec: void*, str: string, on: string){
    let count: int = count_substr(str, on) + 1;
    let split_str: string* = split(str, on);
    for (let mut i: int = 0; i < count; i = i + 1) {
        fpush_back(vec, stof(split_str[i]));
    }
}

extern intvec() -> void*;
extern ipush_back(vec: void*, val: int);
extern getveci(vec: void*, idx: int) -> int;

struct Vec<int> {
    vector: void*,
    size: int,

    fn Vec<int>(self: Vec<int>) -> Vec<int> {
        self.vector = intvec();
        self.size = 0;
        return self;
    }
    
    fn size(self: Vec<int>) -> int {
        return self.size;
    }

    fn append(self: Vec<int>, n: int) {
        ipush_back(self.vector, n);
        self.size = self.size + 1;
    }

    fn get(self: Vec<int>, idx: int) -> int {
        return getveci(self.vector, idx);
    }
}

extern floatvec() -> void*;
extern fpush_back(vec: void*, val: float);
extern getvecf(vec: void*, idx: int) -> float;

struct Vec<float> {
    vector: void*,
    size: int,

    fn Vec<float>(self: Vec<float>) -> Vec<float> {
        self.vector = floatvec();
        self.size = 0;
        return self;
    }
    
    fn size(self: Vec<float>) -> int {
        return self.size;
    }

    fn append(self: Vec<float>, n: float) {
        fpush_back(self.vector, n);
        self.size = self.size + 1;
    }

    fn get(self: Vec<float>, idx: int) -> float {
        return getvecf(self.vector, idx);
    }
}
