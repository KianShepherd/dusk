extern copyi(arr: int*, n: int) -> int*;
extern copyd(arr: float*, n: int) -> float*;
extern copys(arr: string, n: int) -> string;
extern copysa(arr: string*, n: int) -> string*;

extern ialloc(n: int) -> int*;
extern falloc(n: int) -> float*;
extern newstruct(n: int) -> void*;

extern del(arr: int*) -> int;
extern delet(arr: void*);
fn delete(arr: void*) {
    delet(arr);
}

extern ftoi(a: float) -> int;
extern ftos(a: float) -> string;

extern itof(a: int) -> float;
extern itos(a: int) -> string;

extern ltof(a: long) -> float;
extern ltoi(a: long) -> int;
extern ltos(a: long) -> string;

extern stoi(a: string) -> int;
extern stof(a: string) -> float;

extern input() -> string;
extern readfile(filename: string) -> string;

extern count_substr(str: string, substr: string) -> int;
extern split(str: string, on: string) -> string*;




fn split<int>(mut vec: void*, str: string, on: string){
    let count: int = count_substr(str, on) + 1;
    let split_str: string* = split(str, on);
    for (let mut i: int = 0; i < count; i = i + 1) {
        ipush_back(vec, stoi(split_str[i]));
    }
}

fn split<float>(mut vec: void*, str: string, on: string){
    let count: int = count_substr(str, on) + 1;
    let split_str: string* = split(str, on);
    for (let mut i: int = 0; i < count; i = i + 1) {
        fpush_back(vec, stof(split_str[i]));
    }
}

struct String {
    extern new_str() -> void*;
    extern new_str_preset(text: string) -> void*;
    extern print_str(str: void*);

    str: void*,

    fn String(self: String) -> String {
        self.str = new_str();
        return self;
    }

    fn String(self: String, str: string) -> String {
        self.str = new_str_preset(str);
        return self;
    }

    fn print(self: String) {
        print_str(self.str);
    }
}

struct Vec<int> {
    extern intvec() -> void*;
    extern ipush_back(vec: void*, val: int);
    extern ipush_front(vec: void*, val: int);
    extern getveci(vec: void*, idx: int) -> int;

    vector: void*,
    size: int,

    fn Vec<int>(self: Vec<int>) -> Vec<int> {
        self.vector = intvec();
        self.size = 0;
        return self;
    }
    
    fn size(self: Vec<int>) -> int {
        return self.size;
    }

    fn append(self: Vec<int>, n: int) {
        ipush_back(self.vector, n);
        self.size = self.size + 1;
    }

    fn prepend(self: Vec<int>, n: int) {
        ipush_front(self.vector, n);
        self.size = self.size + 1;
    }

    fn get(self: Vec<int>, idx: int) -> int {
        return getveci(self.vector, idx);
    }

    fn extend(self: Vec<int>, vec: Vec<int>) {
        let size: int = vec.size();
        for (let mut i: int = 0; i < size; i = i + 1) {
            ipush_back(self.vector, vec.get(i));
        }
    }
}

struct Vec<float> {
    extern floatvec() -> void*;
    extern fpush_back(vec: void*, val: float);
    extern fpush_front(vec: void*, val: float);
    extern getvecf(vec: void*, idx: int) -> float;

    vector: void*,
    size: int,

    fn Vec<float>(self: Vec<float>) -> Vec<float> {
        self.vector = floatvec();
        self.size = 0;
        return self;
    }
    
    fn size(self: Vec<float>) -> int {
        return self.size;
    }

    fn append(self: Vec<float>, n: float) {
        fpush_back(self.vector, n);
        self.size = self.size + 1;
    }

    fn prepend(self: Vec<float>, n: float) {
        fpush_front(self.vector, n);
        self.size = self.size + 1;
    }

    fn get(self: Vec<float>, idx: int) -> float {
        return getvecf(self.vector, idx);
    }

    fn extend(self: Vec<float>, vec: Vec<float>) {
        let size: int = vec.size();
        for (let mut i: int = 0; i < size; i = i + 1) {
            fpush_back(self.vector, vec.get(i));
        }
    }
}
