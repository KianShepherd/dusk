require "duskvec"

struct String {
    fn split<int>(self: String, on: string) -> Vec<int> {
        let mut vec: Vec<int> = Vec<int>();
        let str: string = to_string(self.str);
        let count: int = count_substr(str, on) + 1;
        let split_str: string* = split(str, on);
        for (let mut i: int = 0; i < count; i++) {
            vec.append(stoi(split_str[i]));
        }
        return vec;
    }

    fn split<float>(self: String, on: string) -> Vec<float> {
        let mut vec: Vec<float> = Vec<float>();
        let str: string = to_string(self.str);
        let count: int = count_substr(str, on) + 1;
        let split_str: string* = split(str, on);
        for (let mut i: int = 0; i < count; i++) {
            vec.append(stof(split_str[i]));
        }
        return vec;
    }

    fn split<String>(self: String, on: string) -> Vec<String> {
        let mut vec: Vec<String> = Vec<String>();
        let str: string = to_string(self.str);
        let count: int = count_substr(str, on) + 1;
        let split_str: string* = split(str, on);
        for (let mut i: int = 0; i < count; i++) {
            let mut tmp_ss: string = split_str[i];
            let mut ss: String = String(tmp_ss);
            vec.append(ss);
        }
        return vec;
    }
}

struct Vec<String> {
    extern vpvec() -> void*;
    extern vppush_back(vec: void*, val: void*);
    extern vppush_front(vec: void*, val: void*);
    extern getvecvp(vec: void*, idx: int) -> void*;

    vector: void*,
    size: int,

    fn Vec<String>(self: Vec<String>) -> Vec<String> {
        self.vector = vpvec();
        self.size = 0;
        return self;
    }
    
    fn size(self: Vec<String>) -> int {
        return self.size;
    }

    fn append(self: Vec<String>, n: String) {
        vppush_back(self.vector, n);
        self.size = self.size + 1;
    }

    fn prepend(self: Vec<String>, n: String) {
        vppush_front(self.vector, n);
        self.size = self.size + 1;
    }

    fn get(self: Vec<String>, idx: int) -> String {
        return getvecvp(self.vector, idx);
    }

    fn extend(self: Vec<String>, vec: Vec<String>) {
        let size: int = vec.size();
        for (let mut i: int = 0; i < size; i++) {
            vppush_back(self.vector, vec.get(i));
        }
    }

    fn __str__(self: Vec<String>) -> string {
        let size: int = self.size();
        let mut ret: String = String("[ ");
        for (let mut i: int = 0; i < size; i++) {
            let mut tmp_str: String = self.get(i); 
            ret = ret + "'" + print_str(tmp_str.str) + "'";
            if (i < self.size() - 1) {
                ret = ret + ", ";
            }
        }
        ret = ret + " ]";
        return print_str(ret.str);
    }
}

struct Vec<int> {
    extern intvec() -> void*;
    extern ipush_back(vec: void*, val: int);
    extern ipush_front(vec: void*, val: int);
    extern getveci(vec: void*, idx: int) -> int;
    extern ivec_str(vec: void*) -> string;

    vector: void*,
    size: int,

    fn Vec<int>(self: Vec<int>) -> Vec<int> {
        self.vector = intvec();
        self.size = 0;
        return self;
    }
    
    fn size(self: Vec<int>) -> int {
        return self.size;
    }

    fn append(self: Vec<int>, n: int) {
        ipush_back(self.vector, n);
        self.size = self.size + 1;
    }

    fn prepend(self: Vec<int>, n: int) {
        ipush_front(self.vector, n);
        self.size = self.size + 1;
    }

    fn get(self: Vec<int>, idx: int) -> int {
        return getveci(self.vector, idx);
    }

    fn extend(self: Vec<int>, vec: Vec<int>) {
        let size: int = vec.size();
        for (let mut i: int = 0; i < size; i++) {
            ipush_back(self.vector, vec.get(i));
        }
    }

    fn __str__(self: Vec<int>) -> string {
        return ivec_str(self.vector);
    }
}

struct Vec<float> {
    extern floatvec() -> void*;
    extern fpush_back(vec: void*, val: float);
    extern fpush_front(vec: void*, val: float);
    extern getvecf(vec: void*, idx: int) -> float;
    extern fvec_str(vec: void*) -> string;

    vector: void*,
    size: int,

    fn Vec<float>(self: Vec<float>) -> Vec<float> {
        self.vector = floatvec();
        self.size = 0;
        return self;
    }
    
    fn size(self: Vec<float>) -> int {
        return self.size;
    }

    fn append(self: Vec<float>, n: float) {
        fpush_back(self.vector, n);
        self.size = self.size + 1;
    }

    fn prepend(self: Vec<float>, n: float) {
        fpush_front(self.vector, n);
        self.size = self.size + 1;
    }

    fn get(self: Vec<float>, idx: int) -> float {
        return getvecf(self.vector, idx);
    }

    fn extend(self: Vec<float>, vec: Vec<float>) {
        let size: int = vec.size();
        for (let mut i: int = 0; i < size; i++) {
            fpush_back(self.vector, vec.get(i));
        }
    }
    
    fn __str__(self: Vec<float>) -> string {
        return fvec_str(self.vector);
    }
}
